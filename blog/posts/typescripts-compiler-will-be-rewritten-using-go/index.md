In an effort to speed up TypeScript compilation, Microsoft has decided to rewrite the compiler to be a native application. There are, of course, a number of languages they could have chosen for this endeavor, but this is why they chose Go:

> Language choice is always a hot topic! We extensively evaluated many language options, both recently and in prior investigations. We also considered hybrid approaches where certain components could be written in a native language, while keeping core typechecking algorithms in JavaScript. We wrote multiple prototypes experimenting with different data representations in different languages, and did deep investigations into the approaches used by existing native TypeScript parsers like swc, oxc, and esbuild. To be clear, *many languages would be suitable in a ground-up rewrite situation*. Go did the best when considering multiple criteria that are particular to this situation, and it’s worth explaining a few of them.
> 
> By far the most important aspect is that we need to keep the new codebase as compatible as possible, both in terms of semantics and in terms of code structure. We expect to maintain both codebases for quite some time going forward. Languages that allow for a structurally similar codebase offer a significant boon for anyone making code changes because we can easily port changes between the two codebases. In contrast, languages that require fundamental rethinking of memory management, mutation, data structuring, polymorphism, laziness, etc., might be a better fit for a ground-up rewrite, but we’re undertaking this more as a *port* that maintains the existing behavior and critical optimizations we’ve built into the language. Idiomatic Go strongly resembles the existing coding patterns of the TypeScript codebase, which makes this porting effort much more tractable.
> 
> Go also offers excellent control of memory *layout and allocation* (both on an object and field level) without requiring that the entire codebase continually concern itself with memory *management*. While this implies a garbage collector, the downsides of a GC aren’t particularly salient in our codebase. We don’t have any strong latency constraints that would suffer from GC pauses/slowdowns. Batch compilations can effectively forego garbage collection entirely, since the process terminates at the end. In non-batch scenarios, most of our up-front allocations (ASTs, etc.) live for the entire life of the program, and we have strong domain information about when “logical” times to run the GC will be. Go’s model therefore nets us a very big win in reducing codebase complexity, while paying very little actual runtime cost for garbage collection.
> 
> We also have an unusually large amount of graph processing, specifically traversing trees in both upward and downward walks involving polymorphic nodes. Go does an excellent job of making this ergonomic, especially in the context of needing to resemble the JavaScript version of the code.
> 
> Acknowledging some weak spots, Go’s in-proc JS interop story is not as good as some of its alternatives. We have upcoming plans to mitigate this, and are committed to offering a performant and ergonomic JS API. We’ve been constrained in certain possible optimizations due to the current API model where consumers can access (or worse, *modify*) practically anything, and want to ensure that the new codebase keeps the door open for more freedom to change internal representations without having to worry about breaking all API users. Moving to a more intentional API design that also takes interop into account will let us move the ecosystem forward while still delivering these huge performance wins.
> 
> [Why Go?](https://github.com/microsoft/typescript-go/discussions/411)

As the first comment in the discussion points out, it’s strange that Microsoft didn’t choose C# instead of Go but at the same time, I suspect it has to do with the points they made about keeping with a similar codebase structure and coding patterns for the sake of an easier and quicker port.

In my opinion, it’s interesting that they are choosing to rewrite the TypeScript script compiler at all. I understand that they want it to be faster which would be great for large frontend projects using TypeScript, but for backend Node applications, the TypeScript compiler may soon become superfluous since [Node 23 includes native support for running TypeScript files](https://www.totaltypescript.com/typescript-is-coming-to-node-23).

You can view the whole thread on GitHub: [https://github.com/microsoft/typescript-go/discussions/411](https://github.com/microsoft/typescript-go/discussions/411)